/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useBudgetContext, BudgetContext, queryKeyFn } from "./budgetContext";
import { deepMerge } from "./budgetUtils";
import type * as Fetcher from "./budgetFetcher";
import { budgetFetch } from "./budgetFetcher";
import type * as Schemas from "./budgetSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type GetTransactionsError = Fetcher.ErrorWrapper<undefined>;

export type GetTransactionsResponse = Schemas.Transaction[];

export type GetTransactionsVariables = BudgetContext["fetcherOptions"];

export const fetchGetTransactions = (
  variables: GetTransactionsVariables,
  signal?: AbortSignal,
) =>
  budgetFetch<
    GetTransactionsResponse,
    GetTransactionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/transactions", method: "get", ...variables, signal });

export function getTransactionsQuery(variables: GetTransactionsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetTransactionsResponse>;
};

export function getTransactionsQuery(
  variables: GetTransactionsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetTransactionsResponse>)
    | reactQuery.SkipToken;
};

export function getTransactionsQuery(
  variables: GetTransactionsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/transactions",
      operationId: "getTransactions",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTransactions(variables, signal),
  };
}

export const useSuspenseGetTransactions = <TData = GetTransactionsResponse,>(
  variables: GetTransactionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTransactionsResponse,
      GetTransactionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBudgetContext(options);
  return reactQuery.useSuspenseQuery<
    GetTransactionsResponse,
    GetTransactionsError,
    TData
  >({
    ...getTransactionsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetTransactions = <TData = GetTransactionsResponse,>(
  variables: GetTransactionsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTransactionsResponse,
      GetTransactionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBudgetContext(options);
  return reactQuery.useQuery<
    GetTransactionsResponse,
    GetTransactionsError,
    TData
  >({
    ...getTransactionsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AddTransactionError = Fetcher.ErrorWrapper<undefined>;

export type AddTransactionVariables = {
  body?: Schemas.Transaction;
} & BudgetContext["fetcherOptions"];

export const fetchAddTransaction = (
  variables: AddTransactionVariables,
  signal?: AbortSignal,
) =>
  budgetFetch<
    Schemas.Transaction,
    AddTransactionError,
    Schemas.Transaction,
    {},
    {},
    {}
  >({ url: "/transactions", method: "post", ...variables, signal });

export const useAddTransaction = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Transaction,
      AddTransactionError,
      AddTransactionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBudgetContext();
  return reactQuery.useMutation<
    Schemas.Transaction,
    AddTransactionError,
    AddTransactionVariables
  >({
    mutationFn: (variables: AddTransactionVariables) =>
      fetchAddTransaction(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteTransactionPathParams = {
  id: string;
};

export type DeleteTransactionError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTransactionVariables = {
  pathParams: DeleteTransactionPathParams;
} & BudgetContext["fetcherOptions"];

export const fetchDeleteTransaction = (
  variables: DeleteTransactionVariables,
  signal?: AbortSignal,
) =>
  budgetFetch<
    Schemas.Transaction,
    DeleteTransactionError,
    undefined,
    {},
    {},
    DeleteTransactionPathParams
  >({ url: "/transactions/{id}", method: "delete", ...variables, signal });

export const useDeleteTransaction = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Transaction,
      DeleteTransactionError,
      DeleteTransactionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBudgetContext();
  return reactQuery.useMutation<
    Schemas.Transaction,
    DeleteTransactionError,
    DeleteTransactionVariables
  >({
    mutationFn: (variables: DeleteTransactionVariables) =>
      fetchDeleteTransaction(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type QueryOperation = {
  path: "/transactions";
  operationId: "getTransactions";
  variables: GetTransactionsVariables | reactQuery.SkipToken;
};
